# 重读《深入理解计算机系统》

## 信息表示和处理

* 加减法比乘法快
* 除法最慢，慢很多
* 位移实现乘法快

## 处理器体系结构

* 基于条件数据传送比基于条件控制转移性能高。因为流水线的执行方式，使用基于条件控制可能导致预测错误，导致指令数目飙高。而基于条件数据传送的方式不依赖条件数据，让流水线一直可以满载正常执行。但要考虑计算不同条件结果的成本，如果成本高就不划算了。

* 64 位 cpu 能将调动过程信息和参数记录在寄存器中（比 x86 多了 8 个寄存器），不需要对这些信息读写栈，大大提高了性能。

* 流水线的并行模式增加了系统的吞吐量，但也带来了少量延迟。若流水线深度过深，延迟增大，导致吞吐量可能下降。

* 流水线的示例：一堆车经过洗车机，不同的步骤同时执行。

* 组合电路显示出一种 React 响应式的特性。

## 优化程序性能

* 消除循环的低效率。即尽可能将成本高的东西在循环外做，循环内只使用结果。

* 减少过程调用，内联。过程调用需要储存返回地址、传递参数等开销，需要很多指令。

* 消除不必要的存储器引用。使用局部值变量，以便让它能够存储到寄存器中，比访问内存快得多。使用指针和数组都会导致读内存。

* 循环展开。将本来一个个轮着来的改成每次多个，减少次数。利用了流水线来处理展开的操作，提高了并行度，并且某种方面减少了操作之间的依赖性。

* 提高并行性。通过更改多个累积变量的结合方式，减少依赖性，能提高流水线的并行处理效率。

* 使用 SIMD，直接提高并行度。

* 同上，可以的话使用基于条件数据传送的方式，而不是用基于条件控制的方式。
```c
//基于条件控制转移的示例
void minmax1(int a[], int b[], int n)
{
    int i;
    for(i = 0; i < n; i++)
    {
        if (a[i] > b[i])
        {
            int t = a[i];
            a[i] = b[i];
            b[i] = t;
        }
    }
}
```
```c
// 基于条件数据传送的实例
void minmax2(int a[], int b[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        int min = a[i] < b[i] ? a[i] : b[i];
        int max = a[i] < b[i] ? b[i] : a[i];
        a[i] = min;
        b[i] = max;
    }
}
```

* 打开 -o2 或更高级别的 -o3 等优化，能够使用更适合的指令和代码结构改变。

* 高级设计。考虑适当的算法和数据结构。
* 基本编码原则：（上面提到的）
    * 消除连续的函数调用。有可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获得更大的效率。
    * 消除不必要的存储器引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。
* 低级优化
    * 展开循环，降低开销，并且使得进一步的优化成为可能。
    * 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。
    * 用功能的风格重写条件操作，使得编译采用条件数据传送。
* 不要因为提高效率损害正确性，引入足够的测试。

* 使用均匀的哈希函数

* Amdahl 定律：加快系统的一部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。

## 存储器层次结构

* 局部性原理：倾向于引用邻近于其他最近引用过的数据项的数据项（空间局部性），或者最近引用过的数据项本身（时间局部性）。

* 具有良好局部性的程序比局部性差的程序性能高。因为缓存是基于局部性的。

* 步长为 1 的引用模式（顺序引用模式）比步长为 k 的好。在存储器中以大步长跳来跳去的程序空间局部性很差。
    * 大对象的数组访问不如小对象的数组访问好
    * 对基本数据对象的访问比对类对象的访问好
    * 值类型比引用类型好

* 取指令局部性：循环体代码会被执行很多次，因此它具有良好的时间局部性。循环体越小，循环迭代次数越多，局部性就越好。

* 由于层次结构中较低层次离 cpu 较远，访问慢，为了补偿这些较长的时间，倾向于使用较大的缓存块。

* 冲突不命中对性能影响很大，因为每次访问都不命中，每次访问都让之前的缓存失效。这跟放置策略有关系，只要使用非随机的放置策略都会有冲突不命中的可能。但使用随机放置会导致定位代价高昂。在实际使用中，可以组织程序访问数据的方式，以避免冲突不命中。
    * 抖动：高速缓存反复地加载和驱逐相同的高速缓存块的组。
    * 冲突不命中在真实的程序中很常见，当程序访问大小为 2 的幂的数组时，直接映射高速缓存缓存中通常会发生冲突不命中。
    * 应对抖动的方法：在访问数组（或其他）的尾部加入某长度字节的填充，将需要读取的两份或多份对象挤到不同的缓存组中，这样就消除了冲突不命中。
```c
//假设一个块是 16 字节（容纳 4 个浮点数），高速缓存有两组，整个大小为 32 字节

//会抖动的版本，虽然具有良好的局部性，但性能不高
float dotprod(float x[8],float y[8])
{
    float aum = 0.0;
    int i;
    for( i = 0; i < 8; i++)
        sum += x[i] * y[i];
    return sum;
}

//只需要将 x 定义为 float x[12]，给它后面增加填充即可以避免这个冲突不命中 (p415)
```

* .NET 的线程池代码貌似用了尾部工作偷取的方法来避免缓存失效，具体如何需要再去看看，到时候更新上来。

* 写缓存
    * 直写：写入的内容写到高速缓存，同时立即写到下一级存储中。
    * 写回：将内容写入高速缓存，等高速缓存块被驱逐时再写回下一级存储。需要给每个高速缓存行增加个 dirty 标志。

* 建议使用写回和写分配模型。

* 使用分块技术提高局部性（p433）。

* 推荐使用如下技术提高局部性：
    * 注意力集中在内循环上，大部分计算和存储器访问都发生在这里。
    * 通过按照数据对象存储在存储器中的顺序，以步长为 1 来读数据，从而使得程序中的空间局部性最大。
    * 一旦从存储器中读入了一个数据对象，就尽可能多使用它，从而使得程序中的时间局部性最大。
    * 对多维数组操作中，空间局部性尤为重要。