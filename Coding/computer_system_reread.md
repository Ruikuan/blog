# 重读《深入理解计算机系统》

## 信息表示和处理

* 加减法比乘法快
* 除法最慢，慢很多
* 位移实现乘法快

## 处理器体系结构

* 基于条件数据传送比基于条件控制转移性能高。因为流水线的执行方式，使用基于条件控制可能导致预测错误，导致指令数目飙高。而基于条件数据传送的方式不依赖条件数据，让流水线一直可以满载正常执行。但要考虑计算不同条件结果的成本，如果成本高就不划算了。

* 64 位 cpu 能将调动过程信息和参数记录在寄存器中（比 x86 多了 8 个寄存器），不需要对这些信息读写栈，大大提高了性能。

* 流水线的并行模式增加了系统的吞吐量，但也带来了少量延迟。若流水线深度过深，延迟增大，导致吞吐量可能下降。

* 流水线的示例：一堆车经过洗车机，不同的步骤同时执行。

* 组合电路显示出一种 React 响应式的特性。

## 优化程序性能

* 消除循环的低效率。即尽可能将成本高的东西在循环外做，循环内只使用结果。

* 减少过程调用，内联。过程调用需要储存返回地址、传递参数等开销，需要很多指令。

* 消除不必要的存储器引用。使用局部值变量，以便让它能够存储到寄存器中，比访问内存快得多。使用指针和数组都会导致读内存。

* 循环展开。将本来一个个轮着来的改成每次多个，减少次数。利用了流水线来处理展开的操作，提高了并行度，并且某种方面减少了操作之间的依赖性。

* 提高并行性。通过更改多个累积变量的结合方式，减少依赖性，能提高流水线的并行处理效率。

* 使用 SIMD，直接提高并行度。

* 同上，可以的话使用基于条件数据传送的方式，而不是用基于条件控制的方式。
```c
//基于条件控制转移的示例
void minmax1(int a[], int b[], int n)
{
    int i;
    for(i = 0; i < n; i++)
    {
        if (a[i] > b[i])
        {
            int t = a[i];
            a[i] = b[i];
            b[i] = t;
        }
    }
}
```
```c
// 基于条件数据传送的实例
void minmax2(int a[], int b[], int n)
{
    int i;
    for (i = 0; i < n; i++)
    {
        int min = a[i] < b[i] ? a[i] : b[i];
        int max = a[i] < b[i] ? b[i] : a[i];
        a[i] = min;
        b[i] = max;
    }
}
```

* 打开 -o2 或更高级别的 -o3 等优化，能够使用更适合的指令和代码结构改变。

* 高级设计。考虑适当的算法和数据结构。
* 基本编码原则：（上面提到的）
    * 消除连续的函数调用。有可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以获得更大的效率。
    * 消除不必要的存储器引用。引入临时变量来保存中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。
* 低级优化
    * 展开循环，降低开销，并且使得进一步的优化成为可能。
    * 通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。
    * 用功能的风格重写条件操作，使得编译采用条件数据传送。
* 不要因为提高效率损害正确性，引入足够的测试。

* 使用均匀的哈希函数

* Amdahl 定律：加快系统的一部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。

## 存储器层次结构

* 局部性原理：倾向于引用邻近于其他最近引用过的数据项的数据项（空间局部性），或者最近引用过的数据项本身（时间局部性）。

* 具有良好局部性的程序比局部性差的程序性能高。因为缓存是基于局部性的。

* 步长为 1 的引用模式（顺序引用模式）比步长为 k 的好。在存储器中以大步长跳来跳去的程序空间局部性很差。

* 取指令局部性：循环体代码会被执行很多次，因此它具有良好的时间局部性。循环体越小，循环迭代次数越多，局部性就越好。